#include <stdio.h>
#include <string.h>
int mem[50][50];
int fun(int m, int n)
{
    if (m == 0 || n == 1)
        return 1;
    if (n > m)
        return mem[m][n] = fun(m, m);                 //如果盘子的数量大于水果，那就把盘子的数量变得和水果一样
    return mem[m][n] = fun(m, n - 1) + fun(m - n, n); //此时一定有m>=n,至少有一个盘子放空+所有盘子都有
}
int main(void)
{
    int t, m, n;
    scanf("%d", &t);
    while (t--)
    {
        memset(mem, 0, sizeof(mem));
        scanf("%d%d", &m, &n);
        printf("%d\n", fun(m, n));
    }
}
// 我们只需要分两种情况：有空盘子和没空盘子。

// 1.有空盘子：
// f(m,n)=f(m,n-1)//有空盘子很多人会有疑问，
// 这不是只有一个空盘子的情况吗？那2个3个空盘子呢？这就需要
// 递归的思想，随着一步一步的将n换成n-1你就会发现那就是2,3个
// 空盘子的情况。

// 2.没有空盘子：
// f(m,n)=f(m-n,n)//没有空盘子，我们可以看
// 成先给每一个盘子放一个苹果，则还剩下m-n个苹果，剩下的问题就
// 是把这m-n个苹果放到n个盘子里的问题了，也许有人会问，m-n个苹
// 果放到n个盘子也会出现空盘子的情况啊，不是和前面的有空盘子重
// 复了？确实，会出现空盘子的情况，但是请注意，他们并不是真的空
// 盘子，因为他们最开始已经放了一个，他们在这里的空代表着这个盘
// 子只有最开始放的一个苹果。