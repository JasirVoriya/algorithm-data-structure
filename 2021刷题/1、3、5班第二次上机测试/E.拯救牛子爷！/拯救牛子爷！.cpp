// 问题 A: 拯救牛子爷！
// 描述
// 牛子爷最终还是没有计算出正确的出口密码，被反卷大队关了起来。反卷大队关了很多人，明天反卷大队会叫若干个人出去处刑，处刑的规则如下：
// 反卷大队将若干个人围成一个圈，然后从第一个人从1开始报数，报道m的人将被拉出去处刑，然后下一个重新重1开始报数，直到圈里只剩下一个人，然后将其放回。
// 请你计算出牛牛子需要站在第几个位置，才会成为最后那个幸运儿。
// 因为不知道反卷大队明天会具体会叫多少人出去，只知道被关起来的一共有n个人。
// 所以牛子爷需要知道大小为k（2<=k<=n）的n-1个圈里，每个圈的安全位置，以便应付明天的处刑。
//
// 格式
// 输入格式
// 一行数据，两个整型n、m。
//
// 输出格式
// 输出n-1行，第i行输出圈的大小为i+1时，不会被处刑的那个位置。
//
// 样例
// 样例输入 Copy
//20 4
// 
// 样例输出 Copy
// 1
// 2
// 2
// 1
// 5
// 2
// 6
// 1
// 5
// 9
// 1
// 5
// 9
// 13
// 1
// 5
// 9
// 13
// 17
// 
#include <bits/stdc++.h>
using namespace std;
int main(void)
{
    ifstream cin;
    ofstream cout;
    cin.open("test1.in");
    cout.open("test1.out");
    int n, m;
    cin >> n >> m;
    int p = 0;
    for (int i = 2; i <= n; i++) {
        p = (p + m) % i;
        cout << p + 1 << endl;
    }
    return 0;
}