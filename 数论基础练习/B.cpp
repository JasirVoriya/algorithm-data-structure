// JNU饭堂前的那块立牌其实是一个超级计算机。小旋写了一个程序，读入一个n个数的排列（即，只由1,2,...,n组成，长度
// 为n），输出原本的排列。今天超级计算机因为没人交网费坏了，输出排列的时候会将i替换成pi，其中pi也是一个长度为n的排
// 列。小旋觉得很奇怪，认为一定是自己输入的次数少了，于是在第一次输入1...n之后，每次将上一次输出的排列再次输入回去
// 。现在artist觉得小旋这个行为过于暴力，她想知道这有多暴力，也就是说小旋最少要试多少次才能让计算机重新输出1,2,3,
// ...n。 答案可能超级大，你只需要输出答案模3*2^30+1=3221225473（一个质数）。
// Input
// 第一行是一个整数T，代表测试样例的数目。(T <= 5)

// 对每一次测试，第一行是一个数n，表示这个排列的长度。（n <= 3e6）

// 第二行有n个整数，代表新的排列A1,...,An。保证这些数字相互不同，且都满足1 <= Ai <= n 。注意：原排列均为1,2,...,n。
// Output
// 对每一次测试，输出一个数ans，代表答案。
// Sample Input
// 2
// 3
// 1 3 2
// 6
// 2 3 4 5 6 1
// Sample Output
// 2
// 6
// note
// 注意模数范围超过了int。 建议使用scanf、printf，而不是cin、cout。
// 样例解释
// sample1：1 2 3 -> 1 3 2（将第2数放在第三位，将第3数放在第2位） -> 1 2 3（将第2数放在第三位，将第3数放在第2位）
// 。 sample2：1 2 3 4 5 6 -> 2 3 4 5 6 1（将第一个数放在了最后一位，将第二个数放在了第一位，将第三个数放在了第二位
// ，将第四个数放在了第三位，将第五个数放在了第4位，将第6个数放在了第五位。） -> ..（六次操作）.. -> 1 2 3 4 5 6
#include <bits/stdc++.h>
using namespace std;
int main(void)
{
    
    return 0;
}